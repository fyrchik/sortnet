package formatter

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"

	"github.com/fyrchik/sortnet/sequence"
)

// Options contains parameters for code generating.
type Options struct {
	// FuncName is sort function name.
	FuncName string
	// OutFile contains output file name.
	OutFile string
	// PackageName contains package name. By default equals to base dir of OutFile.
	PackageName string
	// ArgumentType represents argument type (sort.Interface by default).
	ArgumentType string
}

// WriteFile generates Go function for swapping indices in sequence.
func WriteFile(is sequence.SwapSequence, opts *Options) error {
	b := bytes.NewBuffer(nil)
	writeToBuffer(b, is, opts)

	buf, err := format.Source(b.Bytes())
	if err != nil {
		return fmt.Errorf("BUG: can't format source: %w", err)
	}

	return ioutil.WriteFile(opts.OutFile, buf, os.ModePerm)
}

func writeToBuffer(b *bytes.Buffer, is sequence.SwapSequence, opts *Options) {
	b.WriteString("// Code generated by \"sortnet\"; DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("package %s\n", opts.PackageName))

	if opts.ArgumentType == "" {
		b.WriteString("import \"sort\"\n")
	}

	b.WriteString(fmt.Sprintf("func %s(a ", opts.FuncName))
	if opts.ArgumentType == "" {
		b.WriteString("sort.Interface")
	} else {
		b.WriteString(opts.ArgumentType)
	}
	b.WriteString(") {\n")
	for _, xy := range is {
		b.WriteString(emitCAS(opts, xy[0], xy[1]))
	}
	b.WriteString("}\n")
}

func emitCAS(o *Options, x, y int) string {
	if o.ArgumentType == "" {
		return fmt.Sprintf("if !a.Less(%d, %d) { a.Swap(%d, %d) }\n", x, y, x, y)
	}

	return fmt.Sprintf(`if a[%d] > a[%d] { a[%d], a[%d] = a[%d], a[%d] }
		`, x, y, x, y, y, x)
}
